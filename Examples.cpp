#if !defined(_MSC_VER)
#define VS_CODE
#endif
#include <iostream>
#include <fstream>
using namespace std;
#include <clocale>
#include <string.h>
#if !defined(VS_CODE)
	#include <Windows.h>
#endif
#include "Examples.h"]


// Розглянемо програму переводу цілого чисел з десяткової системи в двійкову:
void Example1()
{
#include <iostream>
#include <clocale>
using namespace std;
int main()
{
h =0000 0000 0000 0000 0000 0000 0000 1010
mb =0000 0000 0000 0000 0000 0000 0000 0100
h&mb =0000 0000 0000 0000 0000 0000 0000 0000
char out[255];
int i, in, ix, n = 0;
double x;
setlocale(LC_CTYPE, "ukr");
cout << " Введіть ціле додатне число:";
cin >> in;
if (in != 0) {
x = in;
do {
x = x / 2.;
ix = x;
if ((x - ix) != 0) out[n] = '1';
else out[n] = '0';
n++;
x = ix;
} while (x >= 1);
}
cout << " Результат:";
for (i = n - 1; i >= 0; i--)
cout << out[i];
 return 0;
}


/* Приклад 2. Використовуючи тільки побітові операції обчислити вираз: x=8*h; y=x/4; Де h – це
данні, які отримано на вході. Вхідні данні та результати обчислення роздрукувати.
Побітовий зсув на один розряд вліво відповідає множенню на 2. Відповідно на один розряд
вправо діленню на 2. Програма буде мати вигляд:*/
void Example2()
{
// #include "stdafx.h"
#include <iostream>
#include <clocale>
using namespace std;
void main(void)
{
setlocale(LC_CTYPE, "ukr");
cout << "Введіть ціле додатне число h";
int h, x, y;
cin >> h; x = h << 3; y = x >> 1;
cout << " h=" << h << " x=" << x << " y=" << y << endl;
}

}
/*
Приклад 3. Використовуючи тільки побітові операції обчислити вираз: x=33*a + (a * 16 –
b*17)/8 + (15*b + 300) /128. Де a, b – це данні (a>b), які отримано на вході. Вхідні данні та
результати обчислення роздрукувати.
(x = a + a * 32 + ( a *16 – b – b*16)/ 8 + (b*16 - b+300)/(128)
 = a + a * 25 + ( a * 24 – b – b * 24)/ 23 + (b*24 –b +300)/( 27)
 = a + (a<<5) + (((a <<4)– b – (b <<4))>>3) + (((b<<4)–b+300)>>7))
*/

void Example3() {
	#include <iostream.h>
int main()
{
setlocale(LC_CTYPE, "ukr");
cout << "Введіть цілі числа a i b(a>b)";
int a, b, x, y;
cin >> a >> b;
x = a + (a<<5) + (((a << 4) - b - (b<<4))>>3) + (((b<<4) - b + 300)>>7);
y = a * 33 + (a * 16 - b * 17)/8 + (15 * b + 300)/128;
cout << " x=" << x << " y=" << y << " a=" << a << " b=" << b << endl;
return 0;
}


}
/*Приклад 4. Нехай отримано повідомлення - h, яке записано у змінну int( для більшості
сучасних платформ змінна типу int замає 4 байти тобто 32-біта). Якщо біт 1 дорівнює 1, а біт 3
дорівнює 0, то необхідно розрахувати вираз x=4*h, інакше x=h/2, Де h – це повідомлення.
Для визначення величини і-го розряду у двійковій системі числення, необхідно
сформувати відповідну маску (можна використати операцію зсуву вліво), далі виконати
побітову операцію &, та для зручності аналізу, зсунути результат вправо на відповідну кількість
розрядів. Наприклад. Нехай є повідомлення: h=00000000000000000000000000001010.
Необхідно визначити величину третього розряду (зліва). Необхідно використати маску
mb=00000000000000000000000000000100 (1<<2). Далі застосовуємо побітове & і отримаємо: */


void Example4() {
	int main(void)
{
setlocale(LC_CTYPE, "ukr");
cout << "Введіть ціле додатне число h";
int h, x, mb1 = 1, mb3 = 1 << 2;
cin >> h;
if ((h&mb1) == 1 && ((h&mb3) >> 2) == 0) x = h << 2;
else x = h >> 1;
cout << " h=" << h << " x=" << x << endl;
return 0;
}


	
}

/* Приклад 5. Задано текст ASCII (текстовий рядок), який складається з 64 букв. Написати
функцію шифрування заданого тексту. Кожна при шифруванні буква тексту буде записана у
елемент, який складається з двох байтів та має структуру:
у бітах 0-3 старша частина, тобто біти 4-7 ASCII - коду букви (4 біти),
у бітах 4-10 позиція букви у рядку (7 біти),
у бітах 12-15 молодша частина, тобто біти 0-3 ASCII - коду букви (4 біти),
11 біт – біт парності отриманого запису (1 біт). */

void Example5() {
	#include <iostream.h>
void Shifruvanna(char S[64], unsigned short Rez[64])
{
unsigned char c;
unsigned short r, t, i, b;
short j;
cin.get(S, 64);
for (i = 0;i<64;i++) //
{
r = 0; // 0000 0000 0000 0000
c = S[i]; // s - 0x73 = 0111 0011
t = c;
r |= t >> 4; // 0000 0000 0000 0111
r |= i << 4; // 0000 0000 0101 0111 if i=5 -> 0000 0000 0000 0101
t = c;
r |= t << 12; // 0011 0000 0101 0111 if i=5 0000 0000 0000 0101
t = 1;
b = 0;
for (j = 0;j<16;j++) // обчислення біта парності
{
if (r&t) {
if (b==0) b = 1; else b = 0;
}
t <<= 1;
}
r |= b << 11; // 0011 0000 0101 0111 if i=5 0000 0000 0000 0101
Rez[i] = r;
}
}
int main()
{
char S[64];
unsigned short Rez[64];
unsigned short i;
cin.get(S, 64);
Shifruvanna(S, Rez);
for (i = 0;i<64;i++)
cout << hex << Rez[i] << endl;
Об’єкто – орієнтоване програмування мовою С++
return 0;
}
	
}
/* Приклад 6.
Задано файл шифрованого текстового, який складається з 128 байтів. Текст складається із 8 рядків по 8
ASCII - символів та зашифрований таким чином, що кожні два байта, представляють собою елемент,
який має таку структуру:
у бітах 0-2 – знаходиться номер рядка букви (3 біти),
у бітах 3-5 – позиція букви у рядку (3 біти),
6 біт – біт парності перших двох полів (1 біт)
у бітах 7-14 ASCII - код букви (8 біт),
15 біт - біт парності попереднього поля (1 біт).
Написати програму розшифрування тексту, якщо біти парності не правильні видати повідомлення про
помилку. */


void Example6() {
	#include <fstream>
#include <iostream>
using namespace std;
int main()
{
char s[8][9],ch;
char so[8][9];
unsigned short sh_dat[64],sd2[64],r,w;
char st[9];
ifstream ifs("in.dat");
if (!ifs) {
cout << "File in.dat not open" << endl; return -1;
}
ofstream ofs("out.dat");
ofstream ofsb("outb.dat", ios::out | ios::binary);
unsigned short i, j, l, b, k, t;
for (i = 0;i < 8;i++)
{
ifs.get(s[i], 9, '\0'); ifs.get(ch);
}
j = 0;
for (i = 0;i < 8; i++)
for (l = 0;l < 8; l++)
{
r = i; // 0000 0000 0000 0___ <- i
w = l << 3;
r |= w; // 0000 0000 00__ _000 <- l
b = 0; t = 1;
for (k = 0;k<6; k++) // обчислення біта парності
{
if (r&t) { if (b == 0) b = 1; else b = 0;
}
t <<= 1;
}
w = 1 << 6;
if (b) r |= w; // 0000 0000 0_000 0000 <- b
w = s[i][l];
w <<= 7;
r |= w;
if (r & 0x4000) r |= 0x8000;
sh_dat[j] = r;
j++;
ofs << hex<<r<<' ';
cout << hex << r << endl;
}
ofsb.write((char*)sh_dat, 64 * sizeof(unsigned short));
ofsb.close();
ifs.close();
//for (i = 0;i < 64;i++) sh_dat[i] = 0;
ifs.open("outb.dat", ios::in | ios::binary);
ifs.read((char*)sd2, 64 * sizeof(unsigned short));
short indi, indj;
for (i = 0;i < 64;i++)
{
r = sd2[i];
indj = r & 0x0038;
indj >>= 3; // 0000 0000 0011 1000 = 0x0038
indi = r&0x0007; // 0000 0000 0000 0111 = 0x0007
w = r&0x7f80; // 0111 1111 1000 0000 = 0x7f80
w >>= 7;
ch = w;
so[indi][indj]=ch;
}
for (i = 0;i < 8; i++) {
for (l = 0;l < 8; l++)
cout << so[i][l];
cout << endl;
}
 return 0;
}
